untracked --init/clone> unmodified --edit file> modified --add> staged --commit> back to unmodified

$ git init
//for whatever directory you're currently in, designates that current directory as a 'gitted' folder. you'll want to start adding files with the following commands

$ rm -rf .git
//essentially a forced recursive remove of the hidden .git directory.
//should not muck with the state of the project.  a reverse git init

$ git clone [url]
//gets all the files found in a git project you found on github.  go to the github page and find the url.  Could also be gotten in http/s

$ git add *
//a multipurpose command to track untracked files, stage unstaged files...
//if adding a directory, it'll add all the files in that directory to be tracked
//you'll have to re-add modified files if you changed them before a commit in order to commit the absolute latest version.  This file will need another add when I check the status.

$ git reset <file>
//removes a file from the staging area that has not yet been committed

$ git rm filename
//this will remove the file from the staging area and then will commit.  The file will also be gone from the working directory so be careful!
//--cached will remove the file from the staging area but will not remove it from the working directory

$ git mv filename updated_filename
//this rename command will rename the file, but its pretty much identical to the command below
$ mv README.txt README
$ git rm README.txt
$ git add README
//essentially a local rename, a removal of the first file in git, and an addition of the renamed file in git.  Its a convenience function.

$ git commit -m 'insert description here'
//commits the staged git files that we added. the -m is to write the message inline
//git commit the optional '-a' allows you to skip the 'add' to stage step and will commit all files that are being tracked.
//--amend allows you to commit again but include it in your previous commit, so that there's no need for a second commit.

$ git branch [name]
//creates a new branch with [name]

$ git checkout [name]
//checks out a branch with [name]
//-b option will create the branch and checkout in one go

$ git status
//while in a gitted directory, run this to see which files are yet to be added, which files are untracked...

$ git diff
//running this is like getting a status except you get details within documents of what changed.  Remember to press Q to exit out of diffs
//this will only track changes that are still unstaged.  Not since the last commit.

$ git log
//views your commit history
//-p shows your more detailed diff history
//-# outputs your entries to the last # entries.
//or try gitk for a visual git logger

$git remote -v
//-v verbose, spells out the different repo urls it pushes to.

$git remote add origin <url>
//this will add an entry to where the remote git server is.  most likely the url will be something like https://github.com/lee-jason/name.git

$git push <reponame> master
//pushes local content to the master branch of the <reponame> remote repository.  <reponame> will probably be 'origin'

$git remote rm <reponame>
//remove the <reponame> remote repository.  Can figure out repo names with command $git remote

.gitignore
//.gitignore is a file that contains a pattern matched list of all the documents to ignore for this project.  You'll want to put things like tmp directories or log files
//.gitignore file will be hidden in your directory.  You'll want to create, and read from it using the unix 'cat' command

cat > filename
//this command will create a new file in the current directory that you're in
//you'll probably want to create your .gitignore file like this
//press ctrl+d when you're done with the document

netstat -tulpn
//will identify which ports are open and being used by applications.

killall {name}
//will stop all processes starting with name.  Good way to stop rogue servers. thanks node

ps aux
//will return a list of processes with corresponding PID

kill -9 {PID}
//if the killall route doesn't work try surgically killing the process

cat >> filename
//this command will add onto the file specified.  If the filename doesn't exist, it'll create the file.

rm filename
//this will remove the filename

rmdir directoryname
//this will remove the directory.  Will prevent you from removing directories that are not empty
//takes optional -r will force remove it even though the directory is not empty.

ls
//will list out folders, files in current directory
//takes optional -a will show all hidden files (files prepended with .. .)

apt-cache search [name]
//where name is a name that you want to find a package of
//you can | grep [text] at the end of it to search within that search for a specific regular expression

dpkg --list
//lists out the current packages you have installed
//your can also pipe a grep in here to filter out the list

apt-get install [name]
//installs specified package name

apt-get remove [name]
//removes the package that you have installed

npm init
//run this at the start of the project so that we have a place to document our dependencies

npm install [module_name]
//allows you to install node_module in default module directory
//--save allows to install in current local folder while also updating the package.json with correct dependency and version

npm uninstall <pkg_name>
//removes the module from module directory, locally first, then default module directory.

/*
* mongo notes
*/
sudo service mongodb start/stop/restart
//apparently needs to be run through the service, don't trust the damn mongo documentation on how to run this.

mongo
//start the mongo js client

use [dbname]

show dbs

show tables
//returns a list of the tables in current db

db.[collection].find()
//returns all values in specified collection.  I think we're to think of a collection as equivalent of a table..

db.[collection].remove()
//removes collection

/*
* mongoose notes
*/
//First create the Schema
var SchemaName = new mongoose.Schema({attrName: {type: Type, [options]}});
//Then create the model that uses the Schema.
//Mongoose takes the first parameter and creates a lowercase pluralised version in the db
//also allows it to be searchable with mongoose.model('Model')
var Model = mongoose.model('Model', SchemaName);
//Then create new objects based off that model
var model = new Model();
//Then save that model into the db
model.save();

/*
* mocha/supertest testing notes
*/
test file must be ran from the root directory of the actual application file... otherwise .get .post paths mess up and can't be found. Don't know why.
